// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: payment_allocations.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPaymentAllocation = `-- name: CreatePaymentAllocation :exec
INSERT INTO payment_allocations (payment_id, billing_period_id, amount_cents)
VALUES ($1, $2, $3)
`

type CreatePaymentAllocationParams struct {
	PaymentID       pgtype.UUID `json:"payment_id"`
	BillingPeriodID pgtype.UUID `json:"billing_period_id"`
	AmountCents     int64       `json:"amount_cents"`
}

func (q *Queries) CreatePaymentAllocation(ctx context.Context, arg CreatePaymentAllocationParams) error {
	_, err := q.db.Exec(ctx, createPaymentAllocation, arg.PaymentID, arg.BillingPeriodID, arg.AmountCents)
	return err
}

const deletePaymentAllocationsByPayment = `-- name: DeletePaymentAllocationsByPayment :exec
DELETE FROM payment_allocations WHERE payment_id = $1
`

func (q *Queries) DeletePaymentAllocationsByPayment(ctx context.Context, paymentID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deletePaymentAllocationsByPayment, paymentID)
	return err
}

const listPaymentAllocationsByPayment = `-- name: ListPaymentAllocationsByPayment :many
SELECT payment_id, billing_period_id, amount_cents, created_at FROM payment_allocations WHERE payment_id = $1 ORDER BY created_at
`

func (q *Queries) ListPaymentAllocationsByPayment(ctx context.Context, paymentID pgtype.UUID) ([]PaymentAllocation, error) {
	rows, err := q.db.Query(ctx, listPaymentAllocationsByPayment, paymentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentAllocation
	for rows.Next() {
		var i PaymentAllocation
		if err := rows.Scan(
			&i.PaymentID,
			&i.BillingPeriodID,
			&i.AmountCents,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
