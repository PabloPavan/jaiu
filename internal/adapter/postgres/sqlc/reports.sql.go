// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: reports.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const delinquentSubscriptions = `-- name: DelinquentSubscriptions :many
SELECT
  s.id AS subscription_id,
  s.student_id,
  s.plan_id,
  s.end_date,
  GREATEST(0, DATE_PART('day', $1::date - s.end_date))::int AS days_overdue
FROM subscriptions s
WHERE s.status = 'active'
  AND s.end_date < $1::date
ORDER BY s.end_date
`

type DelinquentSubscriptionsRow struct {
	SubscriptionID pgtype.UUID `json:"subscription_id"`
	StudentID      pgtype.UUID `json:"student_id"`
	PlanID         pgtype.UUID `json:"plan_id"`
	EndDate        pgtype.Date `json:"end_date"`
	DaysOverdue    int32       `json:"days_overdue"`
}

func (q *Queries) DelinquentSubscriptions(ctx context.Context, dollar_1 pgtype.Date) ([]DelinquentSubscriptionsRow, error) {
	rows, err := q.db.Query(ctx, delinquentSubscriptions, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DelinquentSubscriptionsRow
	for rows.Next() {
		var i DelinquentSubscriptionsRow
		if err := rows.Scan(
			&i.SubscriptionID,
			&i.StudentID,
			&i.PlanID,
			&i.EndDate,
			&i.DaysOverdue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revenueByPeriod = `-- name: RevenueByPeriod :one
SELECT
  $1::timestamptz AS start,
  $2::timestamptz AS end,
  COALESCE(SUM(amount_cents), 0)::bigint AS total_cents
FROM payments
WHERE paid_at >= $1
  AND paid_at < $2
  AND status = 'confirmed'
`

type RevenueByPeriodParams struct {
	Column1 pgtype.Timestamptz `json:"column_1"`
	Column2 pgtype.Timestamptz `json:"column_2"`
}

type RevenueByPeriodRow struct {
	Start      pgtype.Timestamptz `json:"start"`
	End        pgtype.Timestamptz `json:"end"`
	TotalCents int64              `json:"total_cents"`
}

func (q *Queries) RevenueByPeriod(ctx context.Context, arg RevenueByPeriodParams) (RevenueByPeriodRow, error) {
	row := q.db.QueryRow(ctx, revenueByPeriod, arg.Column1, arg.Column2)
	var i RevenueByPeriodRow
	err := row.Scan(&i.Start, &i.End, &i.TotalCents)
	return i, err
}

const studentsByStatus = `-- name: StudentsByStatus :many
SELECT status, COUNT(*)::bigint AS total
FROM students
GROUP BY status
ORDER BY status
`

type StudentsByStatusRow struct {
	Status StudentStatus `json:"status"`
	Total  int64         `json:"total"`
}

func (q *Queries) StudentsByStatus(ctx context.Context) ([]StudentsByStatusRow, error) {
	rows, err := q.db.Query(ctx, studentsByStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StudentsByStatusRow
	for rows.Next() {
		var i StudentsByStatusRow
		if err := rows.Scan(&i.Status, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upcomingDue = `-- name: UpcomingDue :many
SELECT
  s.id AS subscription_id,
  s.student_id,
  s.plan_id,
  s.end_date
FROM subscriptions s
WHERE s.status = 'active'
  AND s.end_date BETWEEN $1::date AND $2::date
ORDER BY s.end_date
`

type UpcomingDueParams struct {
	Column1 pgtype.Date `json:"column_1"`
	Column2 pgtype.Date `json:"column_2"`
}

type UpcomingDueRow struct {
	SubscriptionID pgtype.UUID `json:"subscription_id"`
	StudentID      pgtype.UUID `json:"student_id"`
	PlanID         pgtype.UUID `json:"plan_id"`
	EndDate        pgtype.Date `json:"end_date"`
}

func (q *Queries) UpcomingDue(ctx context.Context, arg UpcomingDueParams) ([]UpcomingDueRow, error) {
	rows, err := q.db.Query(ctx, upcomingDue, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UpcomingDueRow
	for rows.Next() {
		var i UpcomingDueRow
		if err := rows.Scan(
			&i.SubscriptionID,
			&i.StudentID,
			&i.PlanID,
			&i.EndDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
