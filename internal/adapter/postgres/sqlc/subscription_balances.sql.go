// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: subscription_balances.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addSubscriptionBalance = `-- name: AddSubscriptionBalance :one
INSERT INTO subscription_balances (subscription_id, credit_cents)
VALUES ($1, GREATEST($2, 0))
ON CONFLICT (subscription_id)
DO UPDATE SET credit_cents = GREATEST(subscription_balances.credit_cents + $2, 0),
              updated_at = now()
RETURNING subscription_id, credit_cents, updated_at
`

type AddSubscriptionBalanceParams struct {
	SubscriptionID pgtype.UUID `json:"subscription_id"`
	CreditCents    interface{} `json:"credit_cents"`
}

func (q *Queries) AddSubscriptionBalance(ctx context.Context, arg AddSubscriptionBalanceParams) (SubscriptionBalance, error) {
	row := q.db.QueryRow(ctx, addSubscriptionBalance, arg.SubscriptionID, arg.CreditCents)
	var i SubscriptionBalance
	err := row.Scan(&i.SubscriptionID, &i.CreditCents, &i.UpdatedAt)
	return i, err
}

const getSubscriptionBalance = `-- name: GetSubscriptionBalance :one
SELECT subscription_id, credit_cents, updated_at FROM subscription_balances WHERE subscription_id = $1 LIMIT 1
`

func (q *Queries) GetSubscriptionBalance(ctx context.Context, subscriptionID pgtype.UUID) (SubscriptionBalance, error) {
	row := q.db.QueryRow(ctx, getSubscriptionBalance, subscriptionID)
	var i SubscriptionBalance
	err := row.Scan(&i.SubscriptionID, &i.CreditCents, &i.UpdatedAt)
	return i, err
}

const upsertSubscriptionBalance = `-- name: UpsertSubscriptionBalance :one
INSERT INTO subscription_balances (subscription_id, credit_cents)
VALUES ($1, $2)
ON CONFLICT (subscription_id)
DO UPDATE SET credit_cents = EXCLUDED.credit_cents, updated_at = now()
RETURNING subscription_id, credit_cents, updated_at
`

type UpsertSubscriptionBalanceParams struct {
	SubscriptionID pgtype.UUID `json:"subscription_id"`
	CreditCents    int64       `json:"credit_cents"`
}

func (q *Queries) UpsertSubscriptionBalance(ctx context.Context, arg UpsertSubscriptionBalanceParams) (SubscriptionBalance, error) {
	row := q.db.QueryRow(ctx, upsertSubscriptionBalance, arg.SubscriptionID, arg.CreditCents)
	var i SubscriptionBalance
	err := row.Scan(&i.SubscriptionID, &i.CreditCents, &i.UpdatedAt)
	return i, err
}
